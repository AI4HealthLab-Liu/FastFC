{"name":"FastFC","tagline":"Fast Functional Connectivity Toolbox","body":"###Welcome to Fast Functional Connectivity Toolbox.\r\nFastFC is the result of an effort to improve efficiency for Functional Connectivity and related Network measures.\r\nYou can download the executable files (right now only available for Windows x64 systems) here. All functions are developed so that they can be called directly from Matlab's command line.\r\n\r\n### Acknowledgements\r\nPlease do cite our work: \r\n\r\n###Installation\r\n1. Download the latest version of the executables precompiled functions from [here](https://github.com/juangpc/FastFC/zipball/release). Everything you need is in that folder.\r\n1. Include that folder in Matlab's path.\r\n1. Execute testing_fastFC.m from Matlab to check if everything works fine.\r\n1. Read User Manual to understand input and output parameters of each function.\r\n1. Enjoy!\r\n\r\nIf a software package needs to be installed a “specified module could not be found” error message will appear in Matlab’s command line window. For normal installations, all necessary .dll libraries are included and in general, users do not need any further installation. Check out these links to see if this problem can be solved.\r\n\r\nMicrosoft Windows library for multi-thread execution can be found [here](http://www.microsoft.com/en-us/download/confirmation.aspx?id=30679).\r\n\r\nFFTW library for Microsoft Windows 64bit systems can be found [here](http://fftw.org/install/windows.html).  \r\n\r\n###User Manual\r\nIn general terms, Functional Connectivity matrices are computed compactly. Input data is conceived as the whole matrix, column ordered. Each resulting connectivity matrix will be a squared matrix with the same number of rows and columns as the number of columns (number of sensors) of the input data.\r\n\r\nThis approach can derive in an out-of-memory problem when dealing with big data matrices (this is particularly the case of Generalized Synchronization algorithm which is very memory demanding). However, this problem can easily be circumvented by calling the function once for each pair of sensors, and collecting the Functional Connectivity index from the resulting squared matrix of size two.\r\nEqually, all functions computing network indices compute the specified index for every node in the network. This implementation tries to resemble as much as possible Brain Connectivity Toolbox behavior. \r\nAll functions in FastFC are directly accessible from the command line window of Matlab. During execution, each function polls the number of CPU cores present in the computer and deploys an equal number of parallel threads for computing the desired index.\r\n\r\nBoth functions using FFTW subroutine library are the zero phase distortion filter and Phase Synchronization. They both have an input parameter called mode, which allows deciding how exhaustive the search for the optimal FFT algorithm should be. This is a FFTW feature which has been maintained through FastFC. Sometimes it is a good idea to spend a few seconds or even minutes searching for a good algorithm for FFT that can significantly improve performance of subsequent executions. Typically an initial search at the beginning of each MATLAB session can take a few minutes, ensuring an efficient execution which last much less time in every subsequent call to the function. However in general terms mode=1 is more convenient.\r\n##Zero phase distortion filter\r\n\r\n**y=fastfc_filt(filter,data,mode)**\r\n\r\nInput parameters:\r\n*filter = row vector with filter denominator coefficients.\r\n*data = column matrix with data to be filtered. Each sensor should be each column.\r\n*mode = mode for FFT scheduling\r\n*mode = 0 ,  execute fastest but sub-optimal.\r\n*mode = 1 , execute fast but in a sub-optimal algorithm.\r\n*mode = 2 , execute slower the first time, but consider possible faster algorithms.\r\n*mode = 3 , execute slowest the first time, but consider the fastest algorithm.\r\nOutput parameters:\r\n*y = array the same size of data, with each column corresponding to each filtered column of data.\r\n\r\n##Phase Synchronization\r\nPLV. PLI. wPLI are all computed (along with the estimated significance of the PLV) within the MEX function fastfc_ps directly invoked from the MATLAB environment.\r\nIt is important to understand an additional input parameter of this function: samples_to_discard is the number of data samples to discard, to prevent edge effects during the estimation of the Hilbert Transform. The function uses an FFT-based algorithm to estimate the Hilbert Transform, after mirror padding the data, so that discarding of data should be used only for narrow signals where serious edge effects are suspected.\r\n\r\n**[plv,pval_plv,pli,wpli]=fastfc_ps(data,samples_to_discard,mode)**\r\n\r\nInput parameters:\r\n* data = data (sensors by columns).\r\n* samples_to_discard = samples to discard at the beginning and samples to discard at the end of the phase signals. i.e. To discard 200 samples at the beginning and 200 samples at the end of each sensor, samples_to_discard should equal 200.\r\n*         mode = 0 -> execute fastest but suboptimal.\r\n*         mode = 1 -> execute fast but in a suboptimal algorithm.\r\n*         mode = 2 -> execute slower the first time, but consider possible faster algorithms.\r\n*         mode = 3 -> execute slowest the first time, but consider the fastest algorithm.\r\nOutput parameters:\r\n*plv = Phase Locking Value Functional Connectivity matrix.\r\n*pval_plv = pvalue for each index of the PLV matrix. \r\n*pli = Phase Locking Index Functional Connectivity matrix.\r\n*wPli = weighted Phase Locking Functional Connectivity matrix.\r\n\r\n## Mutual Information\r\nThe function implementing the calculation of MI index using k-nearest neighbours, and its corresponding input/output parameters, is defined below.\r\n\r\n**[mi]=fastfc_mi(data,emb_dim,tau,k);**\r\n\r\nInput parameters:\r\n* data = eeg data (sensors by columns).\r\n* emb_dim = embedding dimensions to consider\r\n* tau = time lag to consider for embedding\r\n* k = number of neighbours to consider\r\n\r\nOutput parameters:\r\n*mi = Mutual Information Functional Connectivity matrix\r\n\r\n## Generalized Synchronization\r\nThe function implementing the calculation of GS indices: S, H, M and L, and its corresponding input/output parameters, is defined below.\r\n\r\n**[S,H,M,L]=fastfc_gs(data,emb_dim,tau,k,w,states_eff_step)**\r\n\r\nInput parameters:\r\n* data = eeg data (sensors by columns).\r\n* emb_dim = embedding dimension \r\n* tau = time lag for embedding\r\n* k = number of neighbours to consider\r\n* w = window correction for neighbour finding\r\n* states_eff_step = state-space down sampling to consider when calculating distances\r\n \r\nOutput parameters: \r\n*S, H, M and L = Functional Connectivity matrices for each index.\r\n\r\n## Strength\r\n\r\n**[S]=fastfc_strength_wu(A)**\r\n\r\nInput parameters: \r\n* A = adjacency matrix of real values between 0 and 1, with zeroed principal diagonal elements.\r\nOutput parameters:\r\n* C = a row matrix where every value represents the Strength of each node. \r\n\r\n## Clustering Coefficient\r\n\r\n**[C]=fastfc_cluster_coef_wu(A)**\r\n\r\nInput parameters: \r\n*A = adjacency matrix of nodes by nodes. Values between 0 and 1. Principal diagonal is zero. \r\nOutput parameters:\r\n*C= column matrix where every value represents the Clustering Coefficient of each node. \r\n\r\n## Shortest Path Length\r\n\r\n**[D,L]=fastfc_shortest_path_length_w(W)**\r\n\r\nInput parameters: \r\n*W = directed or undirected weighted connection length matrix.Typically W is obtained by inverting each element in the Functional Connectivity matrix, transforming therefore between weights to length. \r\nOutput parameters:\r\n*D = distance matrix between nodes (shortest weighted path).\r\n*L = number of edges in each shortest weighted path.\r\n\r\n## Betweenness Centrality\r\n\r\nNode Betweenness Centrality \r\n**[D,L,BC]=fastfc_betweenness_cent_w(W)**\r\n\r\nInput parameters: \r\n*W = directed or undirected connection-length matrix.\r\nOutput parameters:\r\nD = distance matrix between nodes (shortest weighted path).\r\nL = number of edges in each shortest weighted path.\r\nBC = node Betweenness Centrality for each node in the network.\r\n\r\n### Developers\r\nThe complete source-code of this project is available at the GitHub page for [FastFC](https://github.com/juangpc/FastFC). Each family of measures is separated in its own branch. Whenever an improvement is made to a function, the final compilation result is copied into the default branch called “release”.\r\n\r\n### Contact & Support\r\nIf you have any doubt or would like to help with Fast FC, please contact me. juangpc (at) ull.edu.es\r\n\r\nJuan Garcia-Prieto ","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}